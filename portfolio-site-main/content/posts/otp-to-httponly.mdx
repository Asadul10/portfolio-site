---
title: "From OTP to HttpOnly Sessions"
slug: "otp-to-httponly"
date: "2024-10-24"
tags: ["Web Security", "Auth", "Cookies", "Security"]
summary: "Migrating from localStorage JWT to HttpOnly cookies for improved security and better user experience."
featured: true
---

# From OTP to HttpOnly Sessions

In the ever-evolving landscape of web security, authentication mechanisms continue to be a critical point of vulnerability. This article explores the migration from client-side JWT storage to HttpOnly cookies, a security enhancement that significantly reduces the attack surface for XSS (Cross-Site Scripting) attacks.

## The Problem with Client-Side Storage

### localStorage Vulnerabilities

Storing JWT tokens in `localStorage` or `sessionStorage` presents several security risks:

- **XSS Attacks**: Malicious scripts can easily access and exfiltrate tokens
- **No Expiration Control**: Tokens persist until explicitly removed
- **CSRF Vulnerability**: Tokens are automatically included in requests
- **Memory Leaks**: Tokens remain in browser memory

```javascript
// Vulnerable approach
const token = localStorage.getItem('authToken');
fetch('/api/protected', {
  headers: {
    'Authorization': `Bearer ${token}`
  }
});
```

### The OTP Challenge

One-Time Passwords (OTPs) add another layer of complexity:

- **Temporary Nature**: OTPs expire quickly, requiring frequent renewal
- **User Experience**: Multiple authentication steps can be cumbersome
- **Storage Complexity**: Managing both JWT and OTP tokens securely

## HttpOnly Cookies: The Solution

### What Are HttpOnly Cookies?

HttpOnly cookies are HTTP cookies that cannot be accessed via JavaScript, providing protection against XSS attacks:

```javascript
// Secure cookie setting
res.cookie('authToken', token, {
  httpOnly: true,
  secure: true,
  sameSite: 'strict',
  maxAge: 3600000 // 1 hour
});
```

### Security Benefits

1. **XSS Protection**: JavaScript cannot access the cookie
2. **Automatic Inclusion**: Cookies are sent automatically with requests
3. **Server Control**: Expiration and validation handled server-side
4. **CSRF Mitigation**: Combined with SameSite attribute

## Implementation Strategy

### Backend Changes

#### Cookie-Based Authentication

```javascript
// Express.js implementation
app.post('/login', async (req, res) => {
  const { email, password } = req.body;
  
  // Validate credentials
  const user = await validateUser(email, password);
  if (!user) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  
  // Generate JWT
  const token = jwt.sign(
    { userId: user.id, email: user.email },
    process.env.JWT_SECRET,
    { expiresIn: '1h' }
  );
  
  // Set HttpOnly cookie
  res.cookie('authToken', token, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict',
    maxAge: 3600000
  });
  
  res.json({ success: true, user: { id: user.id, email: user.email } });
});
```

#### Token Validation Middleware

```javascript
const authenticateToken = (req, res, next) => {
  const token = req.cookies.authToken;
  
  if (!token) {
    return res.status(401).json({ error: 'No token provided' });
  }
  
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded;
    next();
  } catch (error) {
    res.status(403).json({ error: 'Invalid token' });
  }
};
```

### Frontend Changes

#### Removing Client-Side Token Management

```javascript
// Before: Manual token handling
const login = async (credentials) => {
  const response = await fetch('/api/login', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(credentials)
  });
  
  const data = await response.json();
  if (data.token) {
    localStorage.setItem('authToken', data.token);
  }
};

// After: Automatic cookie handling
const login = async (credentials) => {
  const response = await fetch('/api/login', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(credentials),
    credentials: 'include' // Important for cookies
  });
  
  return response.json();
};
```

#### API Request Configuration

```javascript
// Configure fetch to include cookies
const apiCall = async (url, options = {}) => {
  return fetch(url, {
    ...options,
    credentials: 'include', // Include cookies in requests
    headers: {
      'Content-Type': 'application/json',
      ...options.headers
    }
  });
};
```

## OTP Integration

### Server-Side OTP Validation

```javascript
app.post('/verify-otp', async (req, res) => {
  const { email, otp } = req.body;
  
  // Validate OTP
  const isValid = await validateOTP(email, otp);
  if (!isValid) {
    return res.status(401).json({ error: 'Invalid OTP' });
  }
  
  // Generate session token
  const token = jwt.sign(
    { userId: user.id, email: user.email, verified: true },
    process.env.JWT_SECRET,
    { expiresIn: '24h' }
  );
  
  // Set HttpOnly cookie
  res.cookie('authToken', token, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict',
    maxAge: 86400000 // 24 hours
  });
  
  res.json({ success: true });
});
```

### Frontend OTP Flow

```javascript
const verifyOTP = async (email, otp) => {
  try {
    const response = await apiCall('/api/verify-otp', {
      method: 'POST',
      body: JSON.stringify({ email, otp })
    });
    
    if (response.ok) {
      // User is now authenticated via HttpOnly cookie
      window.location.href = '/dashboard';
    } else {
      const error = await response.json();
      throw new Error(error.message);
    }
  } catch (error) {
    console.error('OTP verification failed:', error);
  }
};
```

## Security Considerations

### CSRF Protection

While HttpOnly cookies protect against XSS, they can be vulnerable to CSRF attacks:

```javascript
// CSRF token implementation
const csrfToken = crypto.randomBytes(32).toString('hex');

// Include in response
res.cookie('csrfToken', csrfToken, {
  httpOnly: true,
  secure: true,
  sameSite: 'strict'
});

// Validate in requests
const validateCSRF = (req, res, next) => {
  const token = req.headers['x-csrf-token'];
  const cookieToken = req.cookies.csrfToken;
  
  if (!token || token !== cookieToken) {
    return res.status(403).json({ error: 'Invalid CSRF token' });
  }
  
  next();
};
```

### Token Refresh Strategy

```javascript
// Automatic token refresh
app.post('/refresh-token', authenticateToken, (req, res) => {
  const newToken = jwt.sign(
    { userId: req.user.userId, email: req.user.email },
    process.env.JWT_SECRET,
    { expiresIn: '1h' }
  );
  
  res.cookie('authToken', newToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict',
    maxAge: 3600000
  });
  
  res.json({ success: true });
});
```

## Migration Checklist

### Phase 1: Backend Preparation
- [ ] Implement HttpOnly cookie authentication
- [ ] Add CSRF protection
- [ ] Update API endpoints to use cookies
- [ ] Implement token refresh mechanism
- [ ] Add comprehensive logging

### Phase 2: Frontend Updates
- [ ] Remove localStorage token management
- [ ] Update API calls to include credentials
- [ ] Implement proper error handling
- [ ] Update authentication state management
- [ ] Test all user flows

### Phase 3: Testing & Deployment
- [ ] Security testing (XSS, CSRF)
- [ ] Performance testing
- [ ] User acceptance testing
- [ ] Gradual rollout with feature flags
- [ ] Monitor for issues and rollback plan

## Performance Impact

### Positive Impacts
- **Reduced JavaScript Bundle**: No client-side token management
- **Automatic Request Handling**: No manual header management
- **Server-Side Control**: Better token lifecycle management

### Considerations
- **Cookie Size**: HttpOnly cookies add to request headers
- **Network Overhead**: Cookies sent with every request
- **Server Load**: Token validation on every request

## Best Practices

### Cookie Configuration
```javascript
const cookieOptions = {
  httpOnly: true,           // Prevent XSS
  secure: true,            // HTTPS only
  sameSite: 'strict',      // CSRF protection
  maxAge: 3600000,         // 1 hour expiration
  path: '/'                // Available site-wide
};
```

### Error Handling
```javascript
const handleAuthError = (error) => {
  if (error.status === 401) {
    // Redirect to login
    window.location.href = '/login';
  } else if (error.status === 403) {
    // Show access denied message
    showError('Access denied');
  }
};
```

## Conclusion

Migrating from client-side JWT storage to HttpOnly cookies significantly improves application security by eliminating XSS vulnerabilities while maintaining a smooth user experience. The key is proper implementation of CSRF protection and careful consideration of the authentication flow.

The migration process requires coordination between frontend and backend teams, but the security benefits far outweigh the implementation effort. With proper planning and testing, this migration can be completed with minimal user impact while dramatically improving the security posture of your application.

Remember: Security is not a one-time implementation but an ongoing process. Regular security audits, penetration testing, and staying updated with the latest security practices are essential for maintaining a secure authentication system.
